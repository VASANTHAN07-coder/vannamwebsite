import React, { useState, useRef, useMemo, useEffect } from 'react';
import { useDropzone } from 'react-dropzone';
import { Upload, RefreshCw, AlertCircle } from 'lucide-react';
import { useLanguage } from '../context/LanguageContext';
import { paintDatabase } from '../data/paintDatabase';
import {
    validateBuildingImage,
    performWallSegmentation,
    buildWallMask,
    analyzeLighting,
    applyRealisticPaint,
    blendEdges,
    improvedWallDetection
} from '../utils/improvedPaintEngine'; // Use improved version
import styles from './Visualizer.module.css';
import wallImageDefault from '../assets/wallimg.jpeg';

const ALL_TONES = ['violet', 'indigo', 'blue', 'green', 'yellow', 'orange', 'red', 'neutral'];

const Visualizer = () => {
    const { t } = useLanguage();
    const [image, setImage] = useState(null);
    const [imageLoaded, setImageLoaded] = useState(false);
    const [paintType, setPaintType] = useState('interior');
    const [selectedTone, setSelectedTone] = useState('all');
    const [selectedBrand, setSelectedBrand] = useState('all');
    const [selectedColor, setSelectedColor] = useState(null);
    const [toolMode, setToolMode] = useState('wallFill');
    const [analyzing, setAnalyzing] = useState(false);
    const [analysisResult, setAnalysisResult] = useState(null);
    const [validationError, setValidationError] = useState(null);
    const [lightingData, setLightingData] = useState(null);
    const [processingStage, setProcessingStage] = useState('');
    const [wallBoundaryCanvas, setWallBoundaryCanvas] = useState(null);
    const canvasRef = useRef(null);
    const lastAutoPaintRef = useRef(null);
    const wallMaskMapRef = useRef(null);

    const formatLabel = (value, fallback = 'Unknown') => {
        if (!value || typeof value !== 'string') return fallback;
        return value
            .split(/[_\s-]+/)
            .filter(Boolean)
            .map(part => part.charAt(0).toUpperCase() + part.slice(1))
            .join(' ');
    };

    const getActiveMaskSource = () => {
        // Priority: AI mask > fallback detection
        if (wallMaskMapRef.current) {
            return {
                mask: wallMaskMapRef.current,
                width: wallMaskMapRef.currentWidth,
                height: wallMaskMapRef.currentHeight
            };
        }
        if (wallBoundaryCanvas?.wallMap) {
            return {
                mask: wallBoundaryCanvas.wallMap,
                width: wallBoundaryCanvas.width,
                height: wallBoundaryCanvas.height
            };
        }
        return null;
    };

    const mapMaskToCanvas = (maskData, sourceWidth, sourceHeight) => {
        const canvas = canvasRef.current;
        if (!canvas || !maskData || !sourceWidth || !sourceHeight) return null;
        if (sourceWidth === canvas.width && sourceHeight === canvas.height) return maskData;
        
        const scaled = new Uint8Array(canvas.width * canvas.height);
        const scaleX = sourceWidth / canvas.width;
        const scaleY = sourceHeight / canvas.height;
        
        for (let y = 0; y < canvas.height; y++) {
            const sy = Math.min(Math.floor(y * scaleY), sourceHeight - 1);
            for (let x = 0; x < canvas.width; x++) {
                const sx = Math.min(Math.floor(x * scaleX), sourceWidth - 1);
                scaled[y * canvas.width + x] = maskData[sy * sourceWidth + sx];
            }
        }
        return scaled;
    };

    const paintWallSegment = (startX, startY, colorHex) => {
        if (!selectedColor) return;
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        const maskSource = getActiveMaskSource();
        if (!maskSource) return;

        const { mask: sourceMask, width: maskWidth, height: maskHeight } = maskSource;
        if (!sourceMask) return;

        const scaleX = canvas.width / maskWidth;
        const scaleY = canvas.height / maskHeight;
        const mapX = Math.floor(startX / scaleX);
        const mapY = Math.floor(startY / scaleY);
        
        if (mapX < 0 || mapX >= maskWidth || mapY < 0 || mapY >= maskHeight) return;

        const startIdx = mapY * maskWidth + mapX;
        if (sourceMask[startIdx] !== 1) return;

        // Flood fill to find connected wall region
        const regionMask = new Uint8Array(maskWidth * maskHeight);
        const visited = new Uint8Array(maskWidth * maskHeight);
        const stack = [startIdx];
        visited[startIdx] = 1;

        while (stack.length) {
            const idx = stack.pop();
            if (sourceMask[idx] !== 1) continue;
            regionMask[idx] = 1;

            const x = idx % maskWidth;
            const y = Math.floor(idx / maskWidth);
            const neighbors = [idx - 1, idx + 1, idx - maskWidth, idx + maskWidth];

            for (const nIdx of neighbors) {
                if (nIdx < 0 || nIdx >= regionMask.length || visited[nIdx]) continue;
                const nx = nIdx % maskWidth;
                const ny = Math.floor(nIdx / maskWidth);
                if (Math.abs(nx - x) + Math.abs(ny - y) !== 1) continue;
                visited[nIdx] = 1;
                if (sourceMask[nIdx] === 1) stack.push(nIdx);
            }
        }

        const normalizedRegion = mapMaskToCanvas(regionMask, maskWidth, maskHeight);
        if (!normalizedRegion) return;

        const painted = applyRealisticPaint(
            imageData,
            normalizedRegion,
            colorHex,
            lightingData,
            canvas.width,
            canvas.height,
            {
                surfaceCondition: analysisResult?.details?.condition,
                wallType: analysisResult?.details?.type,
                surfaceType: analysisResult?.details?.surfaceType
            }
        );

        if (painted > 0) {
            blendEdges(imageData, normalizedRegion, canvas.width, canvas.height);
            ctx.putImageData(imageData, 0, 0);
        }
    };

    const paintAllWalls = (colorHex) => {
        if (!selectedColor) return;
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

        const maskSource = getActiveMaskSource();
        if (!maskSource) return;

        const normalizedMask = mapMaskToCanvas(maskSource.mask, maskSource.width, maskSource.height);
        if (!normalizedMask) return;

        const painted = applyRealisticPaint(
            imageData,
            normalizedMask,
            colorHex,
            lightingData,
            canvas.width,
            canvas.height,
            {
                surfaceCondition: analysisResult?.details?.condition,
                wallType: analysisResult?.details?.type,
                surfaceType: analysisResult?.details?.surfaceType
            }
        );

        if (painted > 0) {
            blendEdges(imageData, normalizedMask, canvas.width, canvas.height);
            ctx.putImageData(imageData, 0, 0);
        }
    };

    const analyzeImage = async (img) => {
        setAnalyzing(true);
        setAnalysisResult(null);
        setValidationError(null);
        
        try {
            // Step 1: Validate with Groq (with fallback)
            setProcessingStage('Validating image...');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            const imageDataUrl = canvas.toDataURL('image/jpeg', 0.7);

            let validation;
            try {
                const groqKey = import.meta.env.VITE_GROQ_API_KEY;
                if (!groqKey) throw new Error('No Groq API key');
                
                validation = await validateBuildingImage(imageDataUrl, groqKey);
                console.log('✅ Groq validation:', validation);
            } catch (groqError) {
                console.warn('⚠️ Groq API failed, using fallback validation:', groqError.message);
                validation = {
                    isBuilding: true,
                    type: 'exterior',
                    surfaceType: 'plastered wall',
                    condition: 'clean',
                    reason: null
                };
            }

            if (!validation.isBuilding) {
                setValidationError(validation.reason || 'Not a suitable building image');
                setAnalyzing(false);
                return;
            }

            setValidationError(null);
            setPaintType(validation.type);

            // Step 2: Try AI segmentation with Hugging Face
            setProcessingStage('Detecting walls with AI...');
            wallMaskMapRef.current = null;
            wallMaskMapRef.currentWidth = null;
            wallMaskMapRef.currentHeight = null;

            let aiSegmentationSuccess = false;
            try {
                const hfKey = import.meta.env.VITE_HF_API_KEY;
                if (!hfKey) throw new Error('No HF API key');
                
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', 0.85));
                const segments = await performWallSegmentation(blob, hfKey);
                
                const containerWidth = canvasRef.current?.parentElement?.clientWidth || img.width;
                const scale = Math.min(1, containerWidth / img.width);
                const maskWidth = Math.round(img.width * scale);
                const maskHeight = Math.round(img.height * scale);
                
                const mask = await buildWallMask(segments, maskWidth, maskHeight);
                if (mask) {
                    wallMaskMapRef.current = mask;
                    wallMaskMapRef.currentWidth = maskWidth;
                    wallMaskMapRef.currentHeight = maskHeight;
                    aiSegmentationSuccess = true;
                    console.log('✅ HuggingFace segmentation successful');
                }
            } catch (hfError) {
                console.warn('⚠️ HuggingFace segmentation failed, will use fallback:', hfError.message);
            }

            // Step 3: Analyze lighting
            setProcessingStage('Analyzing lighting...');
            const lighting = analyzeLighting(
                ctx.getImageData(0, 0, canvas.width, canvas.height),
                canvas.width,
                canvas.height
            );
            lighting.surfaceCondition = validation.condition || 'clean';
            lighting.wallType = validation.type;
            lighting.surfaceType = validation.surfaceType || 'plastered wall';
            setLightingData(lighting);

            // Success message
            const method = aiSegmentationSuccess ? 'AI Segmentation' : 'Smart Detection';
            setAnalysisResult({
                message: `${formatLabel(validation.type)} • ${formatLabel(validation.surfaceType)} • ${method}`,
                details: validation
            });

        } catch (error) {
            console.error('Analysis error:', error);
            setValidationError('Analysis failed. Using basic detection.');
        } finally {
            setAnalyzing(false);
            setProcessingStage('');
        }
    };

    // Available brands for filtering
    const availableBrands = useMemo(() => {
        const typeData = paintDatabase[paintType];
        if (!typeData) return [];
        const brands = new Set(ALL_TONES.flatMap(tone => (typeData[tone] || []).map(c => c.brand)));
        return Array.from(brands).sort();
    }, [paintType]);

    // Featured colors (VIBGYOR)
    const featuredColors = useMemo(() => {
        const typeData = paintDatabase[paintType];
        if (!typeData) return [];
        const vibgyorTones = ['violet', 'indigo', 'blue', 'green', 'yellow', 'orange', 'red'];
        const featured = [];
        vibgyorTones.forEach(tone => {
            const toneColors = typeData[tone] || [];
            if (toneColors.length > 0) {
                featured.push(toneColors[Math.floor(toneColors.length * 0.3)]);
            }
        });
        return featured;
    }, [paintType]);

    // Filtered colors based on tone and brand
    const filteredColors = useMemo(() => {
        const typeData = paintDatabase[paintType];
        if (!typeData) return [];
        
        let toneFilter = selectedTone === 'all' ? ALL_TONES : [selectedTone];
        toneFilter = toneFilter.filter(tone => typeData[tone]);
        let colors = toneFilter.flatMap(tone => typeData[tone] || []);
        
        if (selectedBrand !== 'all') {
            colors = colors.filter(c => c.brand === selectedBrand);
        }
        
        return colors;
    }, [paintType, selectedTone, selectedBrand]);

    // Auto-select first color when filters change
    useEffect(() => {
        if (filteredColors.length > 0 && (!selectedColor || !filteredColors.find(c => c.code === selectedColor.code))) {
            setSelectedColor(filteredColors[0]);
        }
    }, [filteredColors, selectedColor]);

    // Draw image on canvas
    const drawImage = (img) => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        const containerWidth = canvas.parentElement?.clientWidth || 800;
        const scale = Math.min(1, containerWidth / img.width);
        canvas.width = img.width * scale;
        canvas.height = img.height * scale;
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        
        // Fallback wall detection using improved algorithm
        const wallData = improvedWallDetection(img, canvas.width);
        setWallBoundaryCanvas(wallData);
    };

    useEffect(() => {
        if (image && canvasRef.current) {
            setTimeout(() => drawImage(image), 50);
        }
    }, [image]);

    // Auto-paint when color changes
    useEffect(() => {
        if (image && selectedColor && wallBoundaryCanvas && toolMode === 'wallFill') {
            const key = `${image.src}|${selectedColor.code}`;
            if (lastAutoPaintRef.current !== key) {
                lastAutoPaintRef.current = key;
                drawImage(image);
                setTimeout(() => paintAllWalls(selectedColor.hex), 80);
            }
        }
    }, [selectedColor, image, wallBoundaryCanvas, toolMode]);

    // Load default image on mount
    useEffect(() => {
        const img = new Image();
        img.onload = () => {
            setImage(img);
            setImageLoaded(true);
            setTimeout(() => analyzeImage(img), 100);
        };
        img.src = wallImageDefault;
    }, []);

    // Handlers
    const handleCanvasClick = (e) => {
        if (!image || !selectedColor) return;
        const rect = canvasRef.current.getBoundingClientRect();
        const x = Math.floor(e.clientX - rect.left);
        const y = Math.floor(e.clientY - rect.top);
        paintWallSegment(x, y, selectedColor.hex);
    };

    const handleReset = () => {
        if (image) {
            drawImage(image);
            setAnalysisResult(null);
        }
    };

    const onDrop = (acceptedFiles) => {
        const file = acceptedFiles[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    setImage(img);
                    analyzeImage(img);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    };

    const { getRootProps, getInputProps, isDragActive } = useDropzone({
        onDrop,
        accept: { 'image/*': [] },
        maxFiles: 1
    });

    return (
        <div className={styles.visualizerPage}>
            <div className="container">
                <h1 className="title-gradient">{t('visualizer.title')}</h1>
                
                {validationError && (
                    <div className={styles.errorBanner}>
                        <AlertCircle size={20} />
                        {validationError}
                    </div>
                )}

                <div className={styles.workspace}>
                    {/* Tone Selector */}
                    <div className={styles.featuredColorsOutside}>
                        <h3>Select Tone (VIBGYOR)</h3>
                        <div className={styles.toneSelector}>
                            <button
                                type="button"
                                className={`${styles.toneBtn} ${selectedTone === 'all' ? styles.activeTone : ''}`}
                                onClick={() => setSelectedTone('all')}
                            >
                                All
                            </button>
                            {ALL_TONES.map(tone => (
                                <button
                                    type="button"
                                    key={tone}
                                    className={`${styles.toneBtn} ${selectedTone === tone ? styles.activeTone : ''}`}
                                    onClick={() => setSelectedTone(tone)}
                                >
                                    {formatLabel(tone)}
                                </button>
                            ))}
                        </div>
                    </div>

                    {/* Main Canvas Area */}
                    <div className={styles.mainArea}>
                        {!image ? (
                            <div
                                {...getRootProps()}
                                className={`${styles.dropzone} ${isDragActive ? styles.dragActive : ''}`}
                            >
                                <input {...getInputProps()} />
                                <Upload size={48} />
                                <p>Drag building image or click to upload</p>
                            </div>
                        ) : (
                            <div className={styles.canvasContainer}>
                                <canvas ref={canvasRef} onClick={handleCanvasClick} />
                                {analyzing && (
                                    <div className={styles.overlay}>
                                        <div className={styles.spinner}></div>
                                        <p>{processingStage}</p>
                                    </div>
                                )}
                                {analysisResult && (
                                    <div className={styles.badge}>
                                        {analysisResult.message}
                                    </div>
                                )}
                            </div>
                        )}
                    </div>

                    {/* Color Sidebar */}
                    <div className={styles.sidebar}>
                        <div className={styles.sidebarContent}>
                            <h3 style={{ marginTop: '0' }}>All Shades</h3>

                            <h3 style={{ fontSize: '0.8rem', marginTop: '1rem', marginBottom: '1rem' }}>
                                Select Brand
                            </h3>
                            <select
                                value={selectedBrand}
                                onChange={(e) => setSelectedBrand(e.target.value)}
                                className={styles.brandSelect}
                            >
                                <option value="all">All Brands</option>
                                {availableBrands.map(brand => (
                                    <option key={brand} value={brand}>{brand}</option>
                                ))}
                            </select>

                            <div className={styles.colorGridWrapper}>
                                <div className={styles.colorGrid}>
                                    {filteredColors.map(color => {
                                        const isActive = selectedColor?.code === color.code;
                                        return (
                                            <button
                                                type="button"
                                                key={`${color.code}-${color.brand}`}
                                                className={`${styles.colorItem} ${isActive ? styles.activeColor : ''}`}
                                                onClick={() => setSelectedColor(color)}
                                            >
                                                <div
                                                    className={styles.colorChip}
                                                    style={{ backgroundColor: color.hex }}
                                                    title={`${color.name} • ${color.code}`}
                                                />
                                                <div className={styles.colorMeta}>
                                                    <span className={styles.colorCode}>{color.code}</span>
                                                    <span className={styles.colorName}>{color.name}</span>
                                                    <span className={styles.colorBrand}>{color.brand}</span>
                                                </div>
                                            </button>
                                        );
                                    })}
                                </div>
                            </div>

                            <button className={styles.resetBtn} onClick={handleReset}>
                                <RefreshCw size={16} /> Reset
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    );
};

export default Visualizer;